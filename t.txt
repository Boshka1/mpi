#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>   // Подключение библиотеки OpenMP

int main(int argc, char *argv[]) {
    // Размер вектора. Берем 100 млн элементов, чтобы вычисления заняли заметное время
    long N = 100000000; 
    
    // Выделяем память под массив (в куче, так как массив большой ~800 МБ)
    double *vector = (double*)malloc(N * sizeof(double));
    if (vector == NULL) {
        printf("Ошибка выделения памяти!\n");
        return 1;
    }

    // Инициализация вектора (заполняем единицами)
    // Это тоже можно распараллелить, но нас интересует замер времени именно вычисления нормы
    #pragma omp parallel for
    for (long i = 0; i < N; i++) {
        vector[i] = 1.0;
    }

    double sum_squares = 0.0; // Переменная для накопления суммы квадратов
    double start_time, end_time;

    printf("Начало вычислений с использованием %d потоков...\n", omp_get_max_threads());

    // Засекаем время
    start_time = omp_get_wtime();

    // ПАРАЛЛЕЛЬНАЯ ОБЛАСТЬ
    // #pragma omp parallel for - указывает, что цикл for нужно разделить между потоками
    // reduction(+:sum_squares) - критически важная часть (объяснение ниже)
    #pragma omp parallel for reduction(+:sum_squares)
    for (long i = 0; i < N; i++) {
        sum_squares += vector[i] * vector[i];
    }

    // Вычисляем корень из суммы квадратов
    double result = sqrt(sum_squares);

    // Останавливаем время
    end_time = omp_get_wtime();

    printf("Результат (Эвклидова норма): %f\n", result);
    printf("Затраченное время: %f секунд\n", end_time - start_time);

    // Освобождаем память
    free(vector);

    return 0;
}



@echo off
echo Compiling...
gcc -fopenmp euclid.c -o euclid.exe

echo.
echo --- TEST 1: 1 Thread ---
set OMP_NUM_THREADS=1
euclid.exe

echo.
echo --- TEST 2: 4 Threads ---
set OMP_NUM_THREADS=4
euclid.exe

echo.
echo --- TEST 3: 8 Threads ---
set OMP_NUM_THREADS=8
euclid.exe

pause

@echo off
echo --- Compiling with MSVC ---
cl /openmp /nologo euclid.c
REM Если ошибка компиляции, попробуйте: cl /openmp /nologo euclid.cpp

echo.
echo =================================
echo TEST 1: 1 Thread (Serial)
set OMP_NUM_THREADS=1
euclid.exe
echo =================================

echo.
echo =================================
echo TEST 2: 4 Threads
set OMP_NUM_THREADS=4
euclid.exe
echo =================================

echo.
echo =================================
echo TEST 3: 8 Threads
set OMP_NUM_THREADS=8
euclid.exe
echo =================================

pause



#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

// Размер вектора (100 млн элементов ~ 800 МБ ОЗУ)
#define N 100000000

int main() {
    // 1. Подготовка данных
    printf("Инициализация вектора (%d элементов)...\n", N);
    double* vector = (double*)malloc(N * sizeof(double));
    if (vector == NULL) {
        printf("Ошибка: не хватает памяти!\n");
        return 1;
    }

    // Заполняем единицами
    #pragma omp parallel for
    for (long i = 0; i < N; i++) {
        vector[i] = 1.0;
    }

    // Определяем количество доступных логических процессоров
    int num_procs = omp_get_num_procs();
    printf("Обнаружено логических процессоров: %d\n\n", num_procs);

    // Массив сценариев: [1 поток, Половина ядер, Все ядра, Ядра * 2]
    int threads_to_test[] = { 1, num_procs / 2, num_procs, num_procs * 2 };
    // Если ядер мало (например 2), num_procs/2 даст 1, будет повтор. Исправим это визуально в таблице.
    
    int num_tests = 4;
    double time_seq = 0.0; // Время последовательного выполнения (для расчета ускорения)

    printf("| %-10s | %-12s | %-15s | %-10s |\n", "Потоки", "Время (сек)", "Результат", "Ускорение");
    printf("|------------|--------------|-----------------|------------|\n");

    // 2. Цикл по экспериментам
    for (int i = 0; i < num_tests; i++) {
        int threads = threads_to_test[i];
        
        // Пропускаем тест 0 потоков, если вдруг вышло деление
        if (threads < 1) threads = 1; 

        // !!! ГЛАВНАЯ КОМАНДА: Устанавливаем число потоков из кода !!!
        omp_set_num_threads(threads);

        double start_time = omp_get_wtime();
        double sum_squares = 0.0;

        // Вычисления (Ядро программы)
        #pragma omp parallel for reduction(+:sum_squares)
        for (long j = 0; j < N; j++) {
            sum_squares += vector[j] * vector[j];
        }
        double result = sqrt(sum_squares);

        double end_time = omp_get_wtime();
        double time_taken = end_time - start_time;

        // Расчет ускорения
        double speedup = 0.0;
        if (i == 0) {
            time_seq = time_taken; // Запоминаем время 1 потока как базовое
            speedup = 1.0;
        } else {
            speedup = time_seq / time_taken;
        }

        // Вывод строки таблицы
        printf("| %-10d | %-12f | %-15f | %-10.2f |\n", threads, time_taken, result, speedup);
    }
    printf("|------------|--------------|-----------------|------------|\n");

    free(vector);
    
    // Чтобы консоль не закрылась сразу (для Windows)
    system("pause");
    return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

// Размер вектора: 100 млн элементов
// Используем long long для индексации больших массивов
const long long N = 100000000;

// Функция для проведения одного эксперимента
double run_experiment(double* vec, long long n, int num_threads) {
    double sum_sq = 0.0;
    double start_time, end_time;
    long long i;

    // Устанавливаем заданное количество потоков
    omp_set_num_threads(num_threads);

    start_time = omp_get_wtime();

    // Параллельная секция с редукцией
    #pragma omp parallel for reduction(+:sum_sq)
    for (i = 0; i < n; ++i) {
        sum_sq += vec[i] * vec[i];
    }

    // Вычисляем корень (сама норма)
    // Переменная volatile используется, чтобы оптимизатор не удалил вычисления,
    // так как результат norm дальше не используется
    volatile double norm = sqrt(sum_sq);

    end_time = omp_get_wtime();

    return end_time - start_time;
}

int main() {
    double* vec;
    int max_procs;
    int threads_to_test[4];
    int num_tests = 0;
    long long i;
    double time_seq = 0.0; // Время выполнения на 1 потоке
    int t_idx;

    // 1. Определение характеристик системы
    max_procs = omp_get_num_procs();
    printf("Detected logical processors: %d\n", max_procs);
    printf("Vector size: %lld elements\n", N);
    
    // 2. Выделение памяти
    printf("Allocating memory (approx %.2f MB)...\n", (double)N * sizeof(double) / 1024.0 / 1024.0);
    vec = (double*)malloc(N * sizeof(double));
    
    if (vec == NULL) {
        printf("Error: Memory allocation failed!\n");
        return 1;
    }

    // 3. Заполнение массива (параллельно для ускорения запуска)
    printf("Initializing data...\n");
    omp_set_num_threads(max_procs);
    #pragma omp parallel for
    for (i = 0; i < N; ++i) {
        // Заполняем простыми значениями
        vec[i] = sin(i * 0.1) * 0.5 + 1.0; 
    }

    // 4. Формирование сценариев тестирования
    // Сценарий 1: 1 поток (последовательно)
    threads_to_test[num_tests++] = 1;
    
    // Сценарий 2: Половина ядер (если их больше 2)
    if (max_procs > 2) {
        threads_to_test[num_tests++] = max_procs / 2;
    }
    
    // Сценарий 3: Ровно столько, сколько ядер
    if (max_procs > 1) { // Чтобы не дублировать 1, если ядро всего одно
        threads_to_test[num_tests++] = max_procs;
    }
    
    // Сценарий 4: В два раза больше ядер (гиперпоточность / перегрузка)
    threads_to_test[num_tests++] = max_procs * 2;

    printf("Data ready. Starting automated benchmarks...\n\n");

    // Шапка таблицы
    printf("%-15s %-15s %-15s\n", "Threads", "Time (sec)", "Speedup");
    printf("---------------------------------------------\n");

    // 5. Цикл экспериментов
    for (t_idx = 0; t_idx < num_tests; t_idx++) {
        int t = threads_to_test[t_idx];
        
        // "Прогрев" (warm-up run) - чтобы кэш процессора заполнился данными
        run_experiment(vec, N, t);

        // Основной замер
        double time = run_experiment(vec, N, t);

        // Если это однопоточный запуск, запоминаем время как эталон
        if (t == 1) {
            time_seq = time;
        }

        double speedup = time_seq / time;

        // Вывод строки таблицы
        printf("%-15d %-15.4f %-15.4fx\n", t, time, speedup);
    }

    // Освобождение памяти
    free(vec);

    printf("\nDone. Press Enter to exit.");
    getchar(); // Ждем нажатия Enter
    return 0;
}
